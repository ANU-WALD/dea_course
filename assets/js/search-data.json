{
  
    
        "post0": {
            "title": "Introduction to Jupyter notebooks",
            "content": "Welcome to the first tutorial in this DEA for Geospatial Analysts course. In this section we introduce the Jupyter notebook environment. Jupyter offers an interactive platform to run Python code in your browser without the need of installing or configuring anything on you computer. The gray cell below contains Python code that you can run placing the cursor on the cell and clicking on the triangle icon on the top menu. . Tip: Use the shortcut Shift-Enter for running the active cell (where your cursor is). It is a convenient &#39;trick&#39; that saves you from having to click on the Run icon each time. . print(&quot;Welcome to the DEA Sandbox!&quot;) . You&#39;ll see that, once the code has executed, any output generated by your code will show up just below the cell . print(&quot;3,2,1&quot;) # Use the hash symbol to comment lines of your code. This does not get executed print(&quot;this is fun!&quot;) . The code that you execute using the DEA Sandbox [Binder, Colab] does not run on your local computer. It runs in a remote server and you just receive the output of the code that gets presented in this browser&#39;s window. . Tip: The last line of code in a cell is evaluated and printed by default, so there is no need to type print() to show the value of a variable in the last line . # Sending a complicated operation to the server result = 999 + 1 # This operation goes to the server and we just display its output in our screens once is completed result . Sometimes the code that you run in a cell takes a while to compute because it loads a large dataset or performs complex computations. You&#39;ll notice the number that appears next to the cell. Before the cell is run you&#39;ll see the symbol [ ] meaning that that cell has not been executed yet. While a cell is running it shows the [*] symbol and once it has completed running you&#39;ll see a number representing the number of cells being run, for example [4]. This allows you to keep track of the cells that have been run and their relative order. . # This is how a library gets imported in Python but don&#39;t worry about this for the moment: import time # Very complicated and long operation computed on the server -- not really we are just waiting or sleeping for 5 seconds :-) time.sleep(5) print(&quot;Done!&quot;) . Jupyter notebooks are an easy way to write Python code, although they work a little bit different to how traditional programs are written and executed. For example, consider this simple Python program: . a = 1 print(a) a = a + 1 print(a) . We can break down this program and execute each line using separate cells: . a = 1 . a . a = a + 1 . a . If you run again the first a cell you&#39;ll see that it returns 2, the updated value. This is called global state and means that once a variable is declared it is accessible anywhere in the notebook, even in cells above where it has been declared. This is different to traditional programs which execute sequentially line by line from the top to the bottom and can be confusing in the beginning. . Jupyter notebooks are designed for interactivity and testing ideas fast. You can modify all the code in the cells and run them as many times as you want in any order (you can jump back and forth to update variables or re-run analysis) . message = &quot;My name is ******&quot; message . You can also add new cells to insert new code at any point in a notebook. Click on the + icon in the top menu to add a new cell below the current one. . Hint: There is a shortcut to add new cells by pressing Esc + a to add a cell just above and Esc + b to add a cell below. . a = 365*24 # Add a new cell just below this one to print the value of variable `a` . The rest of the units in this course use Jupyter notebooks to introduce and get some practice with the different libraries and functionality required to understand the DEA Python interface. After a new concept is introduced there will be cells where you need to answer questions or solve small problems. To check your answers we are going to use an interactive way of . Exercise 0.1 . The following cell contains some code. To complete this exercise you need to update the contents of the operation 2 + 2 for variable a. Delete the current value 0 and write the new value, then execute the cell and see the response. . from check_answer import check_answer a = 0 check_answer(&quot;0.1&quot;, a) . One last thing, you can use code cells to run commands as if you were using a terminal using the ! character before the command. This is a Linux system and to list the contents of the current directory you&#39;ll need to use ls . !ls . You are now ready to start learning Numpy! .",
            "url": "https://anu-wald.github.io/dea_course/numpy/2020/08/12/intro_to_jupyter.html",
            "relUrl": "/numpy/2020/08/12/intro_to_jupyter.html",
            "date": " • Aug 12, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Introduction to Numpy",
            "content": "In order to be able to use numpy we need to import the library using the special word import. Also, to avoid typing numpy every time we want to use one if its functions we can provide an alias using the special word as: . import numpy as np . Now, we have access to all the functions available in numpy by typing np.name_of_function. For example, the equivalent of 1 + 1 in Python can be done in numpy: . np.add(1,1) . Although this might not seem very useful, however, even simple operations like this one, can be much quicker in numpy than in standard Python when using lots of numbers. . To access the documentation explaining how a function is used, its input parameters and output format we can press Shift+Tab after the function name&quot; . np.add . By default the result of a function or operation is shown underneath the cell containing the code. If we want to reuse this result for a later operation we can assign it to a variable: . a = np.add(2,3) . We have just declared a variable a that holds the result of the function. We cannow use of display this variable, at any point of this notebook. For example we can show its contents by typing the variable name in a new cell: . a . Exercise 1.1: Can you use the previous numpy function to add the values 34 and 29 . from check_answer import check_answer # Substitute the ? symbols by the correct expressions and values answ = ? check_answer(&quot;1.1&quot;, answ) . One of numpy&#39;s core concepts is the array, which is equivalent to numpy lists, but can be multidimensional and with much more functionality. To declare a numpy array explicity we do: . np.array([1,2,3,4,5,6,7,8,9]) . Most of the functions and operations defined in numpy can be applied to arrays. For example, with the previous add operation: . arr1 = np.array([1,2,3,4]) arr2 = np.array([3,4,5,6]) np.add(arr1, arr2) . But a more simple and convenient notation can also be used: . Note: This operation detects that numpy arrays are being added and calls the previous function for efficient execution. Think that these arrays can contain large amounts of values. . arr1 + arr2 . Arrays can be sliced and diced. We can get subsets of the arrays using the indexing notation which is [start:end:stride]. Let&#39;s see what this means: . arr = np.array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]) print(arr[5]) print(arr[5:]) print(arr[:5]) print(arr[::2]) . Experiment playing with the indexes to understand the meaning of start, end and stride. What happend if you don&#39;t specify a start? What value numpy uses instead? Note that numpy indexes start on 0, the same convention used in Python lists. . Exercise 1.2: Can you declare a new array with contents [5,4,3,2,1] and slice it to select the last 3 items? . # Substitute the ? symbols by the correct expressions and values arr = ? answ = arr[?:?] check_answer(&quot;1.2&quot;, answ) . Indexes can also be negative, meaning that you start counting by the end. For example, to select the last 2 elements in an array we can do: . arr = np.array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]) arr[-2:] . Exercise 1.3: Can you figure out how to select all the elements in the previous array excluding the last one, [15]? . # Substitute the ? symbols by the correct expressions and values answ = arr[:-1] check_answer(&quot;1.3&quot;, answ) . Exercise 1.4: What about doing excluding the last element from the list but selecting every 3rd element this time? Remember the third index indicates strides if used . Hint: Result should be ?[0,3,6,9,12] . answ = arr[?:?:?] #check_answer(&quot;1.4&quot;, answ) #TODO answ . Numpy arrays can have multiple dimensions. For example, we define a 2-dimensional (1,9) array using nested square brackets [ ]. The convention in numpy is that the outer [ ] represent the first dimension and the inner [ ] contains the last dimension. . . For example the following cell declares a 2-dimensional array with shape (1, 9) . np.array([[1,2,3,4,5,6,7,8,9]]) . To visualise the shape (dimensions) of a numpy array we can add the suffix .shape to an array expression or variable containing a numpy array. . arr1 = np.array([1,2,3,4,5,6,7,8,9]) arr2 = np.array([[1,2,3,4,5,6,7,8,9]]) arr3 = np.array([[1],[2],[3],[4],[5],[6],[7],[8],[9]]) arr1.shape, arr2.shape, arr3.shape, np.array([1,2,3]).shape . Arrays can be reshaped into different shapes using the function reshape: . Note: The total number of elements has to be the same before and after the reshape operation, otherwise numpy will throw and error. . np.array([1,2,3,4,5,6,7,8]).reshape((2,4)) . See the following example how a 9-element array can be reshaped into two dimensional arrays with different shapes. . Note: We are declaring the array and reshaping all in one line. This is called &#39;chaining&#39; and allows us to conveniently perform multiple operations. The expressions are evaluated from left to right, so in this case first we create and array and then apply the reshape operation to the resulting array. . arr1 = np.array([1,2,3,4,5,6,7,8,9]).reshape(1,9) arr2 = np.array([1,2,3,4,5,6,7,8,9]).reshape(9,1) arr3 = np.array([1,2,3,4,5,6,7,8,9]).reshape(3,3) arr1.shape, arr2.shape, arr3.shape . Exercise 1.5: Can you declare a 1-dimensional array with 6 elements and then reshape it into a 2-dimensional array with shape (2,3)? You can try to do this in one or two lines. . # variable answ should contain your 2-dimensional array with shape (2,3) answ = ? check_answer(&quot;1.5&quot;, answ.shape) #TODO [2,3] . There are convenient functions in numpy for declaring common arrays without having to type all their elements: . arr1 = np.arange(9) arr2 = np.ones((3,3)) arr3 = np.zeros((2,2,2)) print(arr1) print(&quot;--&quot;) print(arr2) print(&quot;--&quot;) print(arr3) . Exercise 1.6: Can you declare a 3-dimensional array with shape (5,3,3)? The contents of the array don&#39;t matter for this exercise so you can use any of the previously introduced functions. . # variable answ should contain your 3-dimensional array with shape (5,3,3) answ = ? check_answer(&quot;1.6&quot;, answ.shape) #TODO [5,3,3] . Exercise 1.7: Create another one with the same shape and use the numpy function to add both arrays: . Numpy has useful functions for calculating the mean, standard deviation and sum of the elements of an array. . arr = np.arange(9).reshape((3,3)) print(arr) print(&quot;--&quot;) print(&quot;Mean:&quot;, np.mean(arr)) print(&quot;Std Dev:&quot;, np.std(arr)) print(&quot;Sum:&quot;,np.sum(arr)) . These operation can be performed along specific axis. . arr = np.arange(9).reshape((3,3)) print(arr) print(&quot;--&quot;) print(&quot;Sum along the vertical axis:&quot;, np.sum(arr, axis=0)) print(&quot;--&quot;) print(&quot;Sum along the horizontal axis:&quot;, np.sum(arr, axis=1)) . Exercise 1.8: Declare a 2-dimensional array with shape (20,10) all filled with ones. Then calculate the sum of its values along the first dimension (axis=0). The result has to be a 1-dimensional array with shape (10,) . # variable answ should contain your 3-dimensional array with shape (5,3,3) answ = np.ones((20,10)).sum(axis=0) check_answer(&quot;1.8&quot;, answ) . Numpy arrays can contain numerical values of different types. These types can be divided in these groups: . Integers Unsigned 8 bits: uint8 | 16 bits: uint16 | 32 bits: uint32 | 64 bits: uint64 | . | Signed 8 bits: int8 | 16 bits: int16 | 32 bits: int32 | 64 bits: int64 | . | . | . Floats 32 bits: float32 | 64 bits: float64 | . | . We can look up the type of an array by using the .dtype suffix. . arr = np.ones((10,10,10)) arr.dtype . To specify the type of an array, we can add the dtype parameter to the declaration expression. . arr = np.ones((10,10,10), dtype=np.uint8) arr.dtype . We can also change the type of an existing array using the .astype function. . arr = np.ones((10,10,10)) arr = arr.astype(np.float32) # Or all in one line arr = np.ones((10,10,10)).astype(np.float32) arr.dtype . Exercise 1.9: Change the type of the following array to int16 . answ = np.arange(10) answ = answ#Your code goes here check_answer(&quot;1.9&quot;, answ.dtype) . Broadcasting: numpy is set up internally in a way that allows performing array operations efficiently. Sometimes it is not entirely obvious what is going on. For example: . a = np.zeros((10,10)) a = a + 1 a . The previous operation declares a 10x10 array, assigns that to a variable a and then we add 1 to this variable. However, 1 is a single value and is not even an array so it is not entirely clear what is going on. Broadcasting is the ability in numpy to arrays to replicate or promoted arrays involved in operations to match their shapes. . a = np.arange(9).reshape((3,3)) b = np.arange(3) a + b . Exercise 1.10: Can you declare a new 1-dimensional array with shape (10,) all filled with 2 values? . Hint: We have just seen an example of broadcasting by adding a single value to an array. Broadcasting also works with other operations, such as multiplication or division, so you can complete this exercise declaring an initial array containing all zeros or ones and then using one operation to modify all its values. . answ = ? check_answer(&quot;1.10&quot;, answ) . Boolean values: Numpy arrays normally store numeric values but they can also contain boolean values. Booleans is a data type that can have two possible values: [True, False]. For example: . arr = np.array([True, False, True]) arr, arr.shape, arr.dtype . We can operate with boolean arrays using the numpy functions for performing logical operations such as and, or and others. . arr1 = np.array([True, True, False, False]) arr2 = np.array([True, False, True, False]) print(np.logical_and(arr1, arr2)) print(np.logical_or(arr1, arr2)) . These operations are conveniently offered by numpy with the * and +. . Note: Here the * and + symbols are not performing multiplication and addition as with numerical arrays. Numpy detects the type of the arrays involved in the operation and changes the behaviour of these operators. This ability to change the behaviour of operators depending on the situation is called &#39;operator overloading&#39; in programming languages. . print(arr1 * arr2) print(arr1 + arr2) . Boolean arrays are often the result of comparing a numerical arrays with certain values. This is sometimes useful to detect values that are equal, below or above a number in a numpy array. For example, is we want to know which values in an array are equal to 1 and the values that are greater than 2 we can do: . arr = np.array([1, 3, 5, 1, 6, 3, 1, 5, 7, 1]) print(arr == 1) print(arr &gt; 2) . Exercise 1.11: For this exercise you&#39;ll need to combine array comparisons and logical operators to find out the values in the following array that are greater than 3 and less than 7. . arr = np.array([1, 3, 5, 1, 6, 3, 1, 5, 7, 1]) answ = (arr &gt; 3) * (arr &lt; 7) check_answer(&quot;1.11&quot;, answ) . arr = (arr &gt; 0) print(arr[:,:,4]) arr.dtype . Boolean types are quite handy for indexing and selecting parts of images as we will see later. Many numpy functions also work with Boolean types. . arr = np.array([1,2,3,4,5,6,7,8,9]) mask = np.array([True,False,True,False,True,False,True,False,True]) arr[mask] . Exercise 1.12: Based on the previous example how would you select the values in the array that are greater than 3 and less than 7. In this case you want a new smaller array containing just the values that are within that range. . arr = np.array([1, 3, 5, 1, 6, 3, 1, 5, 7, 1]) answ = arr[(arr&gt;3)*(arr&lt;7)] check_answer(&quot;1.12&quot;, answ) . Depending of the language that you have used before this behaviour in Python might strike you: . a = np.array([0,0,0]) # We make a copy of array a with name b b = a # We modify the first element of b b[0] = 1 print(a) print(b) . Both arrays have been modified. This is in fact because a and b are references to the same underlying array. If you want to have variables with independent arrays you&#39;ll have to use the b = np.copy(a) function to explicitly make a copy of the array. . a = np.array([0,0,0]) # We explicitly make a copy of array a with name b b = np.copy(a) # We modify the first element of b b[0] = 1 print(a) print(b) .",
            "url": "https://anu-wald.github.io/dea_course/numpy/2020/08/11/intro-to-numpy.html",
            "relUrl": "/numpy/2020/08/11/intro-to-numpy.html",
            "date": " • Aug 11, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Introduction to Matplotlib",
            "content": "For the purposes of this tutorial we are going to use a part of matplotlib called pyplot. We import it by doing: . %matplotlib inline import numpy as np from matplotlib import pyplot as plt . An image can be seen as a 2-dimensional array. To visualise the contents of a numpy array: . arr = np.arange(100).reshape(10,10) print(arr) plt.imshow(arr) . Can you create a similar image with an array with shape (50,50)? . We can use the Pyplot library to load an image using the function imread . im = np.copy(plt.imread(&#39;data/black_mountain_fire.jpg&#39;)) . This image is a 3-dimensional numpy array. By convention the first dimension corresponds to the vertical axis, the second to the horizontal axis and the third are the Red, Green and Blue channels of the image. What are the dimensions of the im array? __Hint: Use the .shape property of the im variable. . Let&#39;s display this image using the imshow function. . plt.imshow(im) . This is a photo of Black Mountain taken during prescribed burns in 2014. A colour image is normally composed of three layers containing the values of the red, green and blue pixels. When we display an image we see all three colours combined. . Knowing the extents of the image given by its shape, can you display the values of one of the pixels in the sky? You need to provide one index for each x and y dimensions and get all three channels. Make sure the values represent a mostly blue pixel. . Let&#39;s use the indexing functionality of numpy to select a slice of this image. For example to select the top right corner: . plt.imshow(im[:800,-800:,:]) . Let&#39;s practice your indexing skills! Can you create a cropped image around Black Mountain&#39;s tower? Remember: first dimension is the vertical coordinates, second dimension is the horizontal coordinates and the third are the RGB channels of the image. . Let&#39;s play around with this a little bit. For example, let&#39;s replace all the values in the &#39;red&#39; layer with the value 255, this is the highest red value possible and it will make your whole image redish. The following command will replace all the values in the red channel (axis 3) with the value 255, and see what happens . im[:,:,0] = 255 plt.imshow(im) .",
            "url": "https://anu-wald.github.io/dea_course/numpy/2020/08/10/intro-to-matplotlib.html",
            "relUrl": "/numpy/2020/08/10/intro-to-matplotlib.html",
            "date": " • Aug 10, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Advanced Numpy concepts",
            "content": "Before we start, let&#39;s quickly see a Python data structure called dictionary, which will help understand some of the materials and is also useful to understand how XArray works later on. . A dictionary represents a map between values that can be of different types. Using curly braces we specify the key followed by a semicolon and the value for each element in the dictionary. For example: . d = {1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;tree&#39;} print(d[1], &quot; + &quot;, d[2], &quot; = &quot;, d[3]) . Elements in a dictionary can be modified or new elements added by doing: . d[3] = &#39;three&#39; d[4] = &#39;four&#39; d . Categorical data . First let&#39;s import some libraries: . %matplotlib inline import numpy as np from matplotlib import pyplot as plt from matplotlib import colors . Sometimes remote sensing data contains categorical data as a way of representing classes of individual pixels. . As an example, the following cell simulates a very simple satellite image with three different land cover types. Value 1 represents area covered with grass, 2 croplands and 3 city. . # grass = 1 area = np.ones((100,100)) # crops = 2 area[10:60,20:50] = 2 # city = 3 area[70:90,60:80] = 3 # We map the values to colours index = {1: &#39;green&#39;, 2: &#39;yellow&#39;, 3: &#39;grey&#39;} # Create a discrete colour map cmap = colors.ListedColormap(index.values()) # Plot plt.imshow(area, cmap=cmap) . The harvesting season has arrived and our cropping lands have changed colour to brown. . Can you add a new entry to the index dictionary mapping number 4 to the value brown and regenerate the colourmap? Then using your new indexing skills can you modify the yellow area to contain the new value 4. Finally plot again using the same function to show the change in the season. . ### Your code goes here . Boolean indexing of numpy arrays: . arr = np.arange(10) print(&quot;Before:&quot;, arr) indexes = [True,False,True,False,True,False,True,False,True,False] arr[indexes] . Boolean arrays also allow to assign new values to an array for the True indexes leaving the False indexes intact: . arr[indexes] = -1 arr . Can you use the previous examples to update the following array so that all the values greater or equal to 10 are made equal to 10. This operation is called clipping in Numpy and there is a specific function to do it called np.clip. . arr = np.random.randint(20, size=10) print(&quot;Before:&quot;, arr) ### Your code goes here print(&quot;After clipping:&quot;, arr) . Masking out regions is a very common practice in remote sensing analysis. For example the following image reprensents a satellite image of a region in which there are clouds, shadows and some water. . . We have three files, containing numpy arrays .npy which represent the mask for each category: . These masks are stored as dtype=uint8 using 1 to indicate presence and 0 for absence of each feature. . import matplotlib.gridspec as gridspec plt.figure(figsize=(12,8)) gs = gridspec.GridSpec(1,3) # set up a 1 x 3 grid of images ax1=plt.subplot(gs[0,0]) water_mask = np.load(&quot;data/water_mask.npy&quot;) plt.imshow(water_mask) ax1.set_title(&#39;Water Mask&#39;) ax2=plt.subplot(gs[0,1]) cloud_mask = np.load(&quot;data/cloud_mask.npy&quot;) plt.imshow(cloud_mask) ax2.set_title(&#39;Cloud Mask&#39;) ax3=plt.subplot(gs[0,2]) shadow_mask = np.load(&quot;data/shadow_mask.npy&quot;) plt.imshow(shadow_mask) ax3.set_title(&#39;Shadow Mask&#39;) plt.show() . Let&#39;s load the RGB image, which is a 3-dimensional array of type uint8 with the 3rd dimension corresponding to the colour bands. . Can you use the previous masks to filter clouds, shadows and water out of the image? Hint: Use your new boolean indexing skills and assign pixels in these regions the value 0 . import imageio im = imageio.imread(&#39;data/land_mask.png&#39;) ## Your code here plt.imshow(im) . Bit Flags . Some remote sensing products contain ancillary data describing the quality of each pixel. This quality information is normally encoded using bit flags, in which each bit in a number acts as an &#39;on/off&#39; switch for a particular feature. . For example, a uint8 number is represented in binary format using 8 bits, so it can be used to encode up to 8 different features. . Bit 0: Cloud 00000001 -&gt; 1 | Bit 1: Terrain oclussion 00000010 -&gt; 2 | Bit 3: Saturation 00001000 -&gt; 8 | . So, if one pixel is both classified as cloud and is saturated, the pixel quality mask would be: . 00001001 -&gt; 9 . This is the description of the pixel quality mask of Landsat 8 . . And this is a real example of a pixel quality Landsat 8 image over Margaret River encoded using the previous bit flags. . import rasterio pq = rasterio.open(&#39;data/LC08_L1TP_112084_20190820_20190902_01_T1_BQA.tiff&#39;).read()[0,:,:] print(pq.shape, pq.dtype) plt.imshow(pq) # This function displays unique values in the PQ mask np.unique(pq) . For the value 2720 we can see the binary representation doing: . &quot;{:016b}&quot;.format(2720) . Can you work out what is the interpretation of the 2800 value in the PQ mask? . Analysing data with NaNs. . NaN is a special value of float32 and float64 arrays used to designate Not-a-Number values. . arr = np.array([1,2,3,4,5,np.nan,7,8,9], dtype=np.float32) arr . To compute statistics on arrays containing NaN values, Numpy has special versions of common functions such as mean or std that ignore the NaN values: . print(np.mean(arr)) print(np.nanmean(arr)) . Consider the following uint16 array in which the value 0 designates no data. If we want to compute the mean of all the valid values, we can do converting the array to float type and then assigning the value 0 to NaN. . arr = np.array([234,243,0,231,219,0,228,220,237], dtype=np.uint16) arr = arr.astype(np.float32) arr[arr==0]=np.nan np.nanmean(arr) . Exercise: Can you calculate the mean value of each of the RGB channels for just the area covered with grass in the following image? . . import imageio im = imageio.imread(&#39;data/land_mask.png&#39;)[:,:,:3] print(im.shape) ### Red is im[:,:,0], Green is im[:,:,1], Blue is im[:,:,2] ### You code here .",
            "url": "https://anu-wald.github.io/dea_course/numpy/2020/08/09/advanced_indexing_numpy.html",
            "relUrl": "/numpy/2020/08/09/advanced_indexing_numpy.html",
            "date": " • Aug 9, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Introduction to XArray",
            "content": "DEA uses XArray as its data model. To better understand what it is, let first do a simple experiment using a combination of plain numpy arrays and Python dictionaries. . Suposse we have a satellite image with three bands: Red, NIR and SWIR. These bands are represented as 2-dimensional numpy arrays and the latitude and longitude coordinates for each dimension are represented using 1-dimensional arrays. Finally, we also have some metadata that comes with this image. . import numpy as np red = np.random.rand(250,250) nir = np.random.rand(250,250) swir = np.random.rand(250,250) lats = np.linspace(-23.5, -26.0, num=red.shape[0], endpoint=False) lons = np.linspace(110.0, 112.5, num=red.shape[1], endpoint=False) title = &quot;Image of the desert&quot; date = &quot;2019-11-10&quot; image = {&quot;red&quot;: red, &quot;nir&quot;: nir, &quot;swir&quot;: swir, &quot;latitude&quot;: lats, &quot;longitude&quot;: lons, &quot;title&quot;: title, &quot;date&quot;: date} . All our data is conveniently packed in a dictionary. Now we can use this dictionary to work with the data it contains: . print(image[&quot;date&quot;]) image[&quot;red&quot;].mean() . Still, to select data we have to use numpy indexes. Wouldn&#39;t it be convenient to be able to select data from the images using the coordinates of the pixels instead of their relative positions? . This is exactly what XArray solves! Let&#39;s see how it works: . %matplotlib inline import matplotlib.pyplot as plt from datetime import datetime import numpy as np import xarray as xr . To explore XArray we have a file containing some reflectance data of Canberra that has been generated using the DEA library. . The object that we get ds is a XArray Dataset, which in some ways is very similar to the dictionary that we created before, but with lots of convenient functionality available. . ds = xr.open_dataset(&#39;data/canberra_ls8.nc&#39;) ds . This figure, from the documentation page is quite ilustrative: . . A Dataset can be seen as a dictionary structure packing up the data, dimensions and attributes. . Variables in a Dataset object are called DataArrays and they share dimensions with the higher level Dataset . To access a variable we can access as if it were a Python dictionary, or using the . notation, which is more convenient. . ds[&quot;green&quot;] #or alternatively ds.green . Dimensions are also stored as numeric arrays . ds[&#39;time&#39;] #or alternatively ds.time . Metadata is referred as Attributes and is internally stored under .attrs, but the same convenient . notation applies to them. . ds.attrs[&#39;Conventions&#39;] #or alternatively ds.Conventions . DataArrays store their data internally as multidimensional numpy arrays. But these arrays contain dimensions or labels that make it easier handle the data. To access the underlaying numpy array of a DataArray we can use the .values notation. . arr = ds.green.values type(arr), arr.shape . XArray offers two different ways of selecting data: . isel(): For selecting data based on its index (like numpy). | sel(): For selecting data based on its dimension of label value. | . print(ds.time.values) ss = ds.green.isel(time=0) ss . ss = ds.green.sel(time=datetime(2016,1,1)) ss . ss = ds.green.sel(time=datetime(2016,1,1), latitude=slice(-35.30,-35.24)) ss . Xarray exposes lots of functions to easily transform and analyse Datasets and DataArrays. For example to calculate the spatial mean of the green band . print(&quot;Mean of green band:&quot;, ds.green.mean()) print(&quot;Standard deviation of green band:&quot;, ds.green.std()) print(&quot;Sum of green band:&quot;, ds.green.sum()) . Plotting is also conveniently integrated in the library. . ds[&quot;green&quot;].isel(time=0).plot() . We still can do things manually using numpy and matplotlib . rgb = np.dstack((ds.red.isel(time=0).values, ds.green.isel(time=0).values, ds.blue.isel(time=0).values)) rgb = np.clip(rgb, 0, 2000) / 2000 plt.imshow(rgb) . But compare to this elegant way of chaining operations within XArray . ds[[&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]].isel(time=0).to_array().plot.imshow(robust=True, figsize=(6, 6)) . Exercise: Use the .sel() functionality over the previous image to plot the region defined in the following WKT for 2017: . POLYGON ((149.1 -35.29, 149.13 -35.29, 149.13 -35.27, 149.1 -35.27, 149.1 -35.29)) . Can you create an NDVI representation of this image? .",
            "url": "https://anu-wald.github.io/dea_course/numpy/2020/08/08/intro_to_xarray.html",
            "relUrl": "/numpy/2020/08/08/intro_to_xarray.html",
            "date": " • Aug 8, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://anu-wald.github.io/dea_course/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://anu-wald.github.io/dea_course/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://anu-wald.github.io/dea_course/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://anu-wald.github.io/dea_course/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}