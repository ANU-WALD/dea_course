{
  
    
        "post0": {
            "title": "Introduction to Jupyter notebooks",
            "content": "Welcome to the first tutorial in this DEA for Geospatial Analysts course. In this section we introduce the Jupyter notebook environment. Jupyter offers an interactive platform to run Python code in your browser without the need of installing or configuring anything on you computer. The gray cell below contains Python code that you can run placing the cursor on the cell and clicking on the triangle icon on the top menu. . Tip: Use the shortcut Shift-Enter for running the active cell (where your cursor is). It is a convenient &#39;trick&#39; that saves you from having to click on the Run icon each time. . print(&quot;Welcome to the DEA Sandbox!&quot;) . You&#39;ll see that, once the code has executed, any output generated by your code will show up just below the cell . print(&quot;3,2,1&quot;) # Use the hash symbol to comment lines of your code. This does not get executed print(&quot;this is fun!&quot;) . The code that you execute using the DEA Sandbox [Binder, Colab] does not run on your local computer. It runs in a remote server and you just receive the output of the code that gets presented in this browser&#39;s window. . Tip: The last line of code in a cell is evaluated and printed by default, so there is no need to type print() to show the value of a variable in the last line . # Sending a complicated operation to the server result = 999 + 1 # This operation goes to the server and we just display its output in our screens once is completed result . Sometimes the code that you run in a cell takes a while to compute because it loads a large dataset or performs complex computations. You&#39;ll notice the number that appears next to the cell. Before the cell is run you&#39;ll see the symbol [ ] meaning that that cell has not been executed yet. While a cell is running it shows the [*] symbol and once it has completed running you&#39;ll see a number representing the number of cells being run, for example [4]. This allows you to keep track of the cells that have been run and their relative order. . # This is how a library gets imported in Python but don&#39;t worry about this for the moment: import time # Very complicated and long operation computed on the server -- not really we are just waiting or sleeping for 5 seconds :-) time.sleep(5) print(&quot;Done!&quot;) . Jupyter notebooks are an easy way to write Python code, although they work a little bit different to how traditional programs are written and executed. For example, consider this simple Python program: . a = 1 print(a) a = a + 1 print(a) . We can break down this program and execute each line using separate cells: . a = 1 . a . a = a + 1 . a . If you run again the first a cell you&#39;ll see that it returns 2, the updated value. This is called global state and means that once a variable is declared it is accessible anywhere in the notebook, even in cells above where it has been declared. This is different to traditional programs which execute sequentially line by line from the top to the bottom and can be confusing in the beginning. . Jupyter notebooks are designed for interactivity and testing ideas fast. You can modify all the code in the cells and run them as many times as you want in any order (you can jump back and forth to update variables or re-run analysis) . message = &quot;My name is ******&quot; message . You can also add new cells to insert new code at any point in a notebook. Click on the + icon in the top menu to add a new cell below the current one. . Hint: There is a shortcut to add new cells by pressing Esc + a to add a cell just above and Esc + b to add a cell below. . a = 365*24 # Add a new cell just below this one to print the value of variable `a` . The rest of the units in this course use Jupyter notebooks to introduce and get some practice with the different libraries and functionality required to understand the DEA Python interface. After a new concept is introduced there will be cells where you need to answer questions or solve small problems. To check your answers we are going to use an interactive way of . Exercise 0.1 . The following cell contains some code. To complete this exercise you need to update the contents of the operation 2 + 2 for variable a. Delete the current value 0 and write the new value, then execute the cell and see the response. . from check_answer import check_answer a = 0 check_answer(&quot;0.1&quot;, a) . One last thing, you can use code cells to run commands as if you were using a terminal using the ! character before the command. This is a Linux system and to list the contents of the current directory you&#39;ll need to use ls . !ls . You are now ready to start learning Numpy! .",
            "url": "https://anu-wald.github.io/dea_course/numpy/2020/08/12/intro_to_jupyter.html",
            "relUrl": "/numpy/2020/08/12/intro_to_jupyter.html",
            "date": " • Aug 12, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Introduction to Numpy",
            "content": "In order to be able to use numpy we need to import the library using the special word import. Also, to avoid typing numpy every time we want to use one if its functions we can provide an alias using the special word as: . import numpy as np . Now, we have access to all the functions available in numpy by typing np.name_of_function. For example, the equivalent of 1 + 1 in Python can be done in numpy: . np.add(1,1) . Although this might not seem very useful, however, even simple operations like this one, can be much quicker in numpy than in standard Python when using lots of numbers. . To access the documentation explaining how a function is used, its input parameters and output format we can press Shift+Tab after the function name&quot; . np.add . By default the result of a function or operation is shown underneath the cell containing the code. If we want to reuse this result for a later operation we can assign it to a variable: . a = np.add(2,3) . We have just declared a variable a that holds the result of the function. We cannow use of display this variable, at any point of this notebook. For example we can show its contents by typing the variable name in a new cell: . a . Exercise 1.1: Can you use the previous numpy function to add the values 34 and 29 . from check_answer import check_answer # Substitute the ? symbols by the correct expressions and values answ = ? check_answer(&quot;1.1&quot;, answ) . One of numpy&#39;s core concepts is the array, which is equivalent to numpy lists, but can be multidimensional and with much more functionality. To declare a numpy array explicity we do: . np.array([1,2,3,4,5,6,7,8,9]) . Most of the functions and operations defined in numpy can be applied to arrays. For example, with the previous add operation: . arr1 = np.array([1,2,3,4]) arr2 = np.array([3,4,5,6]) np.add(arr1, arr2) . But a more simple and convenient notation can also be used: . Note: This operation detects that numpy arrays are being added and calls the previous function for efficient execution. Think that these arrays can contain large amounts of values. . arr1 + arr2 . Arrays can be sliced and diced. We can get subsets of the arrays using the indexing notation which is [start:end:stride]. Let&#39;s see what this means: . arr = np.array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]) print(arr[5]) print(arr[5:]) print(arr[:5]) print(arr[::2]) . Experiment playing with the indexes to understand the meaning of start, end and stride. What happend if you don&#39;t specify a start? What value numpy uses instead? Note that numpy indexes start on 0, the same convention used in Python lists. . Exercise 1.2: Can you declare a new array with contents [5,4,3,2,1] and slice it to select the last 3 items? . # Substitute the ? symbols by the correct expressions and values arr = ? answ = arr[?:?] check_answer(&quot;1.2&quot;, answ) . Indexes can also be negative, meaning that you start counting by the end. For example, to select the last 2 elements in an array we can do: . arr = np.array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]) arr[-2:] . Exercise 1.3: Can you figure out how to select all the elements in the previous array excluding the last one, [15]? . # Substitute the ? symbols by the correct expressions and values answ = arr[?] check_answer(&quot;1.3&quot;, answ) . Exercise 1.4: What about doing excluding the last element from the list but selecting every 3rd element this time? Remember the third index indicates strides if used . Hint: Result should be ?[0,3,6,9,12] . answ = arr[?:?:?] check_answer(&quot;1.4&quot;, answ) . Numpy arrays can have multiple dimensions. For example, we define a 2-dimensional (1,9) array using nested square brackets [ ]. The convention in numpy is that the outer [ ] represent the first dimension and the inner [ ] contains the last dimension. . . For example the following cell declares a 2-dimensional array with shape (1, 9) . np.array([[1,2,3,4,5,6,7,8,9]]) . To visualise the shape (dimensions) of a numpy array we can add the suffix .shape to an array expression or variable containing a numpy array. . arr1 = np.array([1,2,3,4,5,6,7,8,9]) arr2 = np.array([[1,2,3,4,5,6,7,8,9]]) arr3 = np.array([[1],[2],[3],[4],[5],[6],[7],[8],[9]]) arr1.shape, arr2.shape, arr3.shape, np.array([1,2,3]).shape . Arrays can be reshaped into different shapes using the function reshape: . Note: The total number of elements has to be the same before and after the reshape operation, otherwise numpy will throw and error. . np.array([1,2,3,4,5,6,7,8]).reshape((2,4)) . See the following example how a 9-element array can be reshaped into two dimensional arrays with different shapes. . Note: We are declaring the array and reshaping all in one line. This is called &#39;chaining&#39; and allows us to conveniently perform multiple operations. The expressions are evaluated from left to right, so in this case first we create and array and then apply the reshape operation to the resulting array. . arr1 = np.array([1,2,3,4,5,6,7,8,9]).reshape(1,9) arr2 = np.array([1,2,3,4,5,6,7,8,9]).reshape(9,1) arr3 = np.array([1,2,3,4,5,6,7,8,9]).reshape(3,3) arr1.shape, arr2.shape, arr3.shape . Exercise 1.5: Can you declare a 1-dimensional array with 6 elements and then reshape it into a 2-dimensional array with shape (2,3)? You can try to do this in one or two lines. . # variable answ should contain your 2-dimensional array with shape (2,3) answ = ? check_answer(&quot;1.5&quot;, answ.shape) . There are convenient functions in numpy for declaring common arrays without having to type all their elements: . arr1 = np.arange(9) arr2 = np.ones((3,3)) arr3 = np.zeros((2,2,2)) print(arr1) print(&quot;--&quot;) print(arr2) print(&quot;--&quot;) print(arr3) . Exercise 1.6: Can you declare a 3-dimensional array with shape (5,3,3)? The contents of the array don&#39;t matter for this exercise so you can use any of the previously introduced functions. . # variable answ should contain your 3-dimensional array with shape (5,3,3) answ = ? check_answer(&quot;1.6&quot;, answ.shape) . Exercise 1.7: Create another one with the same shape and use the numpy function to add both arrays: . Numpy has useful functions for calculating the mean, standard deviation and sum of the elements of an array. . arr = np.arange(9).reshape((3,3)) print(arr) print(&quot;--&quot;) print(&quot;Mean:&quot;, np.mean(arr)) print(&quot;Std Dev:&quot;, np.std(arr)) print(&quot;Sum:&quot;,np.sum(arr)) . These operation can be performed along specific axis. . arr = np.arange(9).reshape((3,3)) print(arr) print(&quot;--&quot;) print(&quot;Sum along the vertical axis:&quot;, np.sum(arr, axis=0)) print(&quot;--&quot;) print(&quot;Sum along the horizontal axis:&quot;, np.sum(arr, axis=1)) . Exercise 1.8: Declare a 2-dimensional array with shape (20,10) all filled with ones. Then calculate the sum of its values along the first dimension (axis=0). The result has to be a 1-dimensional array with shape (10,) . # variable answ should contain your 3-dimensional array with shape (5,3,3) answ = ? check_answer(&quot;1.8&quot;, answ) . Numpy arrays can contain numerical values of different types. These types can be divided in these groups: . Integers Unsigned 8 bits: uint8 | 16 bits: uint16 | 32 bits: uint32 | 64 bits: uint64 | . | Signed 8 bits: int8 | 16 bits: int16 | 32 bits: int32 | 64 bits: int64 | . | . | . Floats 32 bits: float32 | 64 bits: float64 | . | . We can look up the type of an array by using the .dtype suffix. . arr = np.ones((10,10,10)) arr.dtype . To specify the type of an array, we can add the dtype parameter to the declaration expression. . arr = np.ones((10,10,10), dtype=np.uint8) arr.dtype . We can also change the type of an existing array using the .astype function. . arr = np.ones((10,10,10)) arr = arr.astype(np.float32) # Or all in one line arr = np.ones((10,10,10)).astype(np.float32) arr.dtype . Exercise 1.9: Change the type of the following array to int16 . answ = np.arange(10) answ = answ#Your code goes here check_answer(&quot;1.9&quot;, answ.dtype) . Broadcasting: numpy is set up internally in a way that allows performing array operations efficiently. Sometimes it is not entirely obvious what is going on. For example: . a = np.zeros((10,10)) a = a + 1 a . The previous operation declares a 10x10 array, assigns that to a variable a and then we add 1 to this variable. However, 1 is a single value and is not even an array so it is not entirely clear what is going on. Broadcasting is the ability in numpy to arrays to replicate or promoted arrays involved in operations to match their shapes. . a = np.arange(9).reshape((3,3)) b = np.arange(3) a + b . Exercise 1.10: Can you declare a new 1-dimensional array with shape (10,) all filled with 2 values? . Hint: We have just seen an example of broadcasting by adding a single value to an array. Broadcasting also works with other operations, such as multiplication or division, so you can complete this exercise declaring an initial array containing all zeros or ones and then using one operation to modify all its values. . answ = ? check_answer(&quot;1.10&quot;, answ) . Boolean values: Numpy arrays normally store numeric values but they can also contain boolean values. Booleans is a data type that can have two possible values: [True, False]. For example: . arr = np.array([True, False, True]) arr, arr.shape, arr.dtype . We can operate with boolean arrays using the numpy functions for performing logical operations such as and, or and others. . arr1 = np.array([True, True, False, False]) arr2 = np.array([True, False, True, False]) print(np.logical_and(arr1, arr2)) print(np.logical_or(arr1, arr2)) . These operations are conveniently offered by numpy with the * and +. . Note: Here the * and + symbols are not performing multiplication and addition as with numerical arrays. Numpy detects the type of the arrays involved in the operation and changes the behaviour of these operators. This ability to change the behaviour of operators depending on the situation is called &#39;operator overloading&#39; in programming languages. . print(arr1 * arr2) print(arr1 + arr2) . Boolean arrays are often the result of comparing a numerical arrays with certain values. This is sometimes useful to detect values that are equal, below or above a number in a numpy array. For example, is we want to know which values in an array are equal to 1 and the values that are greater than 2 we can do: . arr = np.array([1, 3, 5, 1, 6, 3, 1, 5, 7, 1]) print(arr == 1) print(arr &gt; 2) . Exercise 1.11: For this exercise you&#39;ll need to combine array comparisons and logical operators to find out the values in the following array that are greater than 3 and less than 7. . arr = np.array([1, 3, 5, 1, 6, 3, 1, 5, 7, 1]) answ = ? check_answer(&quot;1.11&quot;, answ) . Boolean types are quite handy for indexing and selecting parts of images as we will see later. Many numpy functions also work with Boolean types. . arr = np.array([1,2,3,4,5,6,7,8,9]) mask = np.array([True,False,True,False,True,False,True,False,True]) arr[mask] . Exercise 1.12: Based on the previous example how would you select the values in the array that are greater than 3 and less than 7. In this case you want a new smaller array containing just the values that are within that range. . arr = np.array([1, 3, 5, 1, 6, 3, 1, 5, 7, 1]) answ = ? check_answer(&quot;1.12&quot;, answ) . Depending of the language that you have used before this behaviour in Python might strike you: . a = np.array([0,0,0]) # We make a copy of array a with name b b = a # We modify the first element of b b[0] = 1 print(a) print(b) . Both arrays have been modified. This is in fact because a and b are references to the same underlying array. If you want to have variables with independent arrays you&#39;ll have to use the b = np.copy(a) function to explicitly make a copy of the array. . a = np.array([0,0,0]) # We explicitly make a copy of array a with name b b = np.copy(a) # We modify the first element of b b[0] = 1 print(a) print(b) .",
            "url": "https://anu-wald.github.io/dea_course/numpy/2020/08/11/intro-to-numpy.html",
            "relUrl": "/numpy/2020/08/11/intro-to-numpy.html",
            "date": " • Aug 11, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Introduction to Matplotlib for image data",
            "content": "For the purposes of this tutorial we are going to use a part of matplotlib called pyplot. We import it by doing: . %matplotlib inline import numpy as np from matplotlib import pyplot as plt . Images are 2-dimensional arrays containing pixels. We can use 2-dimensional arrays to represent image data and visualise with matplotlib: . arr = np.arange(100).reshape(10,10) print(arr) plt.imshow(arr) . Exercise 2.1: Can you create a similar image but with shape (50,50)? . from check_answer import check_answer answ = np.arange(?).reshape(?) plt.imshow(answ) check_answer(&quot;2.1&quot;, answ.sum()) . If you remember from the last tutorial we were able to address regions of a numpy array using the [ ] index notation. For multidimensional arrays we can user , to designate the different axis. For example we can update the values on the left part of this array to be equal to 1. . arr = np.arange(100).reshape(10,10) arr[:, :5] = 1 plt.imshow(arr) . Notice that we have selected all the values : in the first axis (vertical) and the first 5 values :5 on the second axis (horizontal) . Exercise 2.2: Can you do something similar updating all the values in the top-left half corner to 1 . answ = np.arange(100).reshape(10,10) answ[?] = 1 plt.imshow(answ) check_answer(&quot;2.2&quot;, answ.sum()) . Exercise 2.3: Remember how we used boolean arrays in the previous tutorial to select parts of an array? How would you create a boolean array indicating the values that are greater than 49? . Hint: Your new array should be a boolean array with the same shape as the initial array. . answ = np.arange(100).reshape(10,10) answ = ? plt.imshow(answ) check_answer(&quot;2.3&quot;, answ.sum()) . We can use the Pyplot library to load an image using the matplotlib function imread. The image that we get is a 3-dimensional numpy array. By convention the first dimension corresponds to the vertical axis, the second to the horizontal axis and the third are the Red, Green and Blue channels of the image. . im = np.copy(plt.imread(&#39;data/black_mountain_fire.jpg&#39;)) im.shape . Exercise 2.4: Can you find the data type of the previous im array? Remeber the suffix we used in the previous tutorial to find out the type of an array . answ = im.? check_answer(&quot;2.4&quot;, answ) . Let&#39;s display this image using the imshow function. . plt.imshow(im) . This is a photo of Black Mountain (ACT) taken during some prescribed burns in 2014. A colour image is normally composed of three layers containing the values of the red, green and blue pixels. When we display an image we see all three colours combined. . Exersise 2.5: Let&#39;s use the indexing functionality of numpy to select a portion of this image. Would you be able to select the top-right corner of this image with shape (800,800)? Remember there are three axes in this image. . answ = im[?] plt.imshow(answ) check_answer(&quot;2.5&quot;, answ.mean()) . Exercise 2.6: Let&#39;s get some more practice to improve your indexing skills! Can you create a cropped image around Black Mountain&#39;s tower? Remember: first dimension is the vertical coordinates, second dimension is the horizontal coordinates and the third are the RGB channels of the image. . answ = im[?] plt.imshow(answ) . Let&#39;s have a look at one of the pixels in this image. We choose the top-left corner with position (0,0) and show the values of its RGB channels. . im[0,0] . The first value corresponds to the red component, the second to the green and the third to the blue. uint8 can contain values in the range [0-255] so the pixel is mostly blue, which makes sense for a pixel representing the sky. . Now let&#39;s modify the image. What happens if we set all the values representing the green channel to the maximum value? . # We first make a copy to avoid modifying the original image. im2 = np.copy(im) im2[:,:,1] = 255 plt.imshow(im2) . Exercise 2.7: Could you create an artistic representation of the previous image saturating different parts of the image with different colours? We want the top-left quadrant with the red channel saturated, the top-right with the green channel satured, the bottom-left with the blue channel saturated and the bottom-right as it is. . im2 = np.copy(im) im2[?] = 255 im2[?] = 255 im2[?] = 255 plt.imshow(im2) .",
            "url": "https://anu-wald.github.io/dea_course/numpy/2020/08/10/intro-to-matplotlib.html",
            "relUrl": "/numpy/2020/08/10/intro-to-matplotlib.html",
            "date": " • Aug 10, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Basics of Satellite Image Processing",
            "content": "%matplotlib inline import numpy as np from matplotlib import pyplot as plt from check_answer import check_answer . Satellite images are normally stored in formats such as GeoTIFF or NetCDF but here, to avoid importing extra libraries, we have saved a Modis satellite image locally using a numpy specific format .npz. We can load this file into a numpy array by doing: . arr_modis = np.load(&quot;data/modis_cube.npz&quot;)[&quot;nadir&quot;] arr_modis.shape . This file contains a composite image taken by the MODIS Terra and Acqua satellites over an 8-day period. The image correspond to the area of southwest France and north of Spain around mid July 2018. Each pixel has a resolution of 500 meters and there are 7 spectral bands: [red, near infra-red (nir), blue, green, short-wave infra-red (swir) 1, swir2, swir3] . Let&#39;s plot one band (0 -&gt; red) to have quick look at the region: . plt.imshow(arr_modis[:,:,0]) . The MODIS data represents reflectance values (reflected/incident proportion) for each spectral band. Reflectance is a measure that indicates the proportion of the energy at each part of the spectrum that is reflected by the Earth at each spectral band. The values are therefore in the range [0-1]. 0 represent pixel with no reflection (all energy is being absorbed) and 1 represents all energy is reflected. . These values need to be stored as floating point numbers but to save space is a common practice to use 2-bytes integers (int16 vs float32) and then rescale dividing by a large number. . Before we can interpret these images we need to convert the stored values into reflectance values [0-1.0]. To do this conversion for Modis data we use a conversion factor of 10,000. (In Python you can use scientific notation in which 1e4 == 1*10^4 == 10,000) . To scale the values into reflectance values we can perform this operation which applies the division along the whole array element-wise (remember broadcasting): . refl_modis = arr_modis / 1e4 print(&quot;Min:&quot;, arr_modis.min(), &quot;Max:&quot;, arr_modis.max()) print(&quot;Data type:&quot;, arr_modis.dtype) print(&quot;--&quot;) print(&quot;Min:&quot;, refl_modis.min(), &quot;Max:&quot;, refl_modis.max()) print(&quot;Data type:&quot;, refl_modis.dtype) . As we can see, numpy automatically converts the values in the array from integers into floats to performs the division. . Now we are going to create a true colour composite, creating an image by selecting the red, green and blue components of the multispectral image. . Exercise 3.1: This list contains the names of the Modis bands in order as stored in our 7 bands cube: . [red, near infra-red (nir), blue, green, short-wave infra-red (swir) 1, swir2, swir3] . What are the indices corresponding to the red, green and blue values in the previous array? Remember Python starts counting at 0. . # Substitute the ? symbols by the correct values answ = [?,?,?] check_answer(&quot;3.1&quot;, answ) . So far we have seen two different ways of selecting (indexing) values in a numpy array. (1) we can slice/dice an array using the : notation to specify the start and end index along axes. (2) we can use arrays of boolean values to select certain positions. . There is a third way of selecting values in a numpy array in which specific specific positions using a list of numbers. For example in the following array: . arr = np.array([7,5,3,2,4,6]) arr[[4,0,1]] . This mode of selecting specific positions of an array is called &quot;fancy indexing&quot;. As oppossed to boolean selection fancy indexing does not require the list of numbers to have the same size as the applied array. Also we can change the order of the values in the resulting array compared to the initial array. . Exercise 3.2: Use fancy indexing to select the red, green and blue (in this order) channels from the modis reflectance array. Use the result of the previous exercise. . answ = refl_modis[:,:,?] check_answer(&quot;3.2&quot;, answ.shape) . The proportion of light reflected by the Earth&#39;s surface is normally low. We can have a look at the RGB values in the reflectance array to find out the maximum and minimum values. . rgb_modis = refl_modis[:,:,[0,3,2]] rgb_modis.min(), rgb_modis.max() . Only ~4% of the incident light gets reflected in this image. So we are going to rescale this image and make its dynamic range span the [0,1] interval. . rgb_modis = rgb_modis / rgb_modis.max() rgb_modis.min(), rgb_modis.max() . rgb_modis.shape . Now lets plot the RGB image using matplotlib&#39;s imshow function. . Note: The imshow function can display 3-dimensional arrays as RGB images using the following conventions: (1) The axis containing the channels needs to be the last. (2) If data is stored as uint8 its values need to span the whole [0-255] range. (3) If data is stored as float, its values need to span the [0,1] range. . plt.imshow(rgb_modis) . The previous image is a bit dark and it&#39;s hard to see the details in it. To improve its contrast we are going to expand the dynamic range of the lower values in the image by multiplying the array by 3. By doing this, we will lose, or clip, that larger values in the image but will get an improved representation of the lower values to visually assess the image. . plt.imshow(rgb_modis*3) . The previous image is called natural colour because it maps the RGB channels of the image to the red, green and blue. Chainging the order of the bands we can map bands of the satellite to the RGB channels differently, also including other bands outside the visible. The images resulting from alternative mapping between RGB and spectral channels are commonly known as &#39;false coulour&#39;. . Exercise 3.3: Similarly to the previous image, can you generate a false colour image mapping MODIS near-infrared band into the images&#39; red channel? . answ = refl_modis[:,:,[1,3,2]] plt.imshow(answ*30) # *30 is the previous normalisation and scaling, all in one step (approx.) check_answer(&quot;3.3&quot;, answ[-1,-1,:]) . Mapping the near infrared (nir) channel to the red colour we produces an image showing bright red in regions with more vegetation. Different combinations of reflectance bands are used to look at different properties of the land surface. . Exercise 3.4: Try different mappings between MODIS&#39; spectral bands and the RGB channels in the following cell. . answ = refl_modis[:,:,[?,?,?]] plt.imshow(answ*30) . These images using colour composites offer useful visual representations of remote sensing data. Another common way to represent and analyse these images is through the use of normalised indices. These indices are normally computed using two or more spectral bands into a normalised [-1,1] range. There are multiple well-known normalising algorithms used to detect fire scars, water but probably the most famous one is the Normalised Difference Vegetation Index (NDVI) which shows live vegetation. . NDVI=(NIR-Red)/(NIR+Red) . This operation can be performed in numpy using a very similar notation using arrays: . ndvi_modis = (refl_modis[:,:,1]-refl_modis[:,:,0]) / (refl_modis[:,:,1]+refl_modis[:,:,0]) &quot;Shape:&quot;, ndvi_modis.shape, &quot;Max:&quot;, np.nanmax(ndvi_modis), &quot;Min:&quot;, np.nanmin(ndvi_modis) . As opposed to the previous false/true colour images, normalised indices contain just one band. To represent the values in the array we&#39;ll need to use a predefined colour palette to map the values into different colours. . We can pass the imshow function a parameter to specify the color map to use for our NDVI index. We use summer_r, which goes from yellow to green, to represent vegetation in the image. Here you can find a list of the colour maps available. . Note: imshow can create images either from 2-d arrays and 3-d arrays with dimension 3 in the last axis. In the case of 2-d arrays we&#39;d need to specify the colormap we want to use (or display with the default one). Also 2-d images don&#39;t need to be scaled or normalised into a given range, the colour palette in applied dynamically using the min and max values in the array. For images with three channels the colouring is driven using the proportion of each colour specified in the channels. 3-d arrays need to be normalised [0-255] for uint8 arrays or [0-1] for float arrays. . #To make vegetation look green in the image we apply a colour palette that goes from yellow to green. plt.imshow(ndvi_modis, cmap=&#39;summer_r&#39;) . We can adjust how the values are mapped into the colours in the palette by providing the maximum and minimum values to the imshow function. This is useful to plot certain ranges and enhance where vegetation is in an image. For example: . plt.imshow(ndvi_modis, vmin=.2, vmax=.8, cmap=&#39;summer_r&#39;) . Another normalised index is used to monitor changes related to water content in water bodies, using green and NIR wavelengths, defined by McFeeters (1996): . NDWI=(Green-NIR)/(Green+NIR) . Exercise 3.5: Can you calculate the NDWI array for the previous image? . # Modis spectral bands: # [red, near infra-red (nir), blue, green, short-wave infra-red (swir) 1, swir2, swir3] answ = ? plt.imshow(answ, cmap=&#39;winter_r&#39;) check_answer(&quot;3.5&quot;, answ[-1,-1]) . Exercise 3.6: Can you use slice indexing [:, :] to select and region and plot a zoomed-in area of the previous image? . plt.imshow(answ[?:?,?:?], cmap=&#39;winter_r&#39;) . MODIS generates multi-spectral images. When the number of spectral bands is large, we call those images hyperspectral. The following dataset contains hyperspectral images collected from an airplane in February 2014 as it passed over the Australian National University. . High-resolution hyper-spectral data tends to make very large files. To make processing in this tutorial easier, we have packed a numpy array with the just the [red, nir, green, blue] bands. This array is 3-dimensional with the third dimension corresponding to the spectral bands, just like the MODIS data. Let&#39;s start by loading the data: . Note: This array also needs to be converted first to reflectance values dividing it by 1e4. . arr_anu = np.load(&quot;data/anu_cube.npz&quot;)[&quot;array&quot;] refl_anu = arr_anu/1e4 plt.imshow(refl_anu[:,:,1]) &quot;Shape:&quot;, refl_anu.shape . Exercise 3.7: Can you calculate the NDVI index for this image following similar steps to the previous MODIS example? . Note: _We save this variable with name ndvi_anu as it will be used later on._ . answ = ? ndvi_anu = answ plt.imshow(answ, cmap=&#39;summer_r&#39;) check_answer(&quot;3.7&quot;, answ[0,0]) . Similar to NDVI, there is another index called Green Colour Coordinate (GCC), which is an alternative method to NDVI for looking at how green vegetation is. This one does not use the near-infrared band, which is serves as a convenient alternative for sensors that only generate red, green and blue. . GCC = Green / (Red+Green+Blue) . gcc_anu = refl_anu[:,:,2]/(refl_anu[:,:,0]+refl_anu[:,:,2]+refl_anu[:,:,3]) plt.imshow(gcc_anu, cmap=&#39;summer_r&#39;) . Let&#39;s do some classification generating a series of boolean arrays for different ranges of these vegetation indices. We define the following three categories. . Class 1: NDVI equal or greater than 0.5 and GCC greater than 0.4 indicates green, vegetated surfaces. | Class 2: NDVI less than 0.5 and GCC greater than 0.4 indicates surfaces that look green but are not vegetated. | Class 3: NDVI more than 0.5 and GCC less or equal than 0.4 indicates vegetated surfaces that don&#39;t look green. | . Note: Remember that * corresponds to the &#39;AND&#39; logical operation for boolean arrays. . c1 = np.logical_and(ndvi_anu&gt;=0.5, gcc_anu&gt;0.4) c2 = np.logical_and(ndvi_anu&lt;0.5, gcc_anu&gt;0.4) c3 = np.logical_and(ndvi_anu&gt;=0.5, gcc_anu&lt;=0.4) plt.imshow(c1) . imshow can also create binary representations of boolean arrays. . Now we want to stack these three categorical or boolean arrays into a 3-dimensional array to be able to plot a RGB composite image. Numpy&#39;s dstack function stacks 2-dimensional arrays along the third axis, referred as &#39;depth&#39; so the prefix &#39;d&#39; in the name. . class_comp = np.dstack((c1,c2,c3)) class_comp.shape, class_comp.dtype . Now, to be able to generate the RGB image from this image we need to convert it into either uint8 with range [0-255] or into float32 with range [0-1]. . Exercise 3.8: Can you convert the type of the class_comp array into float32? . class_comp = class_comp.? answ = class_comp check_answer(&quot;3.8&quot;, answ.dtype) . Now we can use imshow to plot the RGB representation of these three classes. Remeber C1 is mapped to red, C2, into green and C3 to blue. . plt.imshow(class_comp) . You will see this leaves a fourth class in the image, of pixels that fall in none of the three classes. They show up in black. There are two surfaces that show up &#39;green&#39; and one area that shows mixed black and blue bits. What are they? . This simple classification uses index thresholds, which is a crude but sometimes useful way of classifying images. In this case, it helps to finding unvegetated green surfaces, such as tennis courts and artificial grass. It is also clear that greenish water confounds the classification, however. . Exercise 3.9: Can you try to compute a similar classification image using the previous Modis image? .",
            "url": "https://anu-wald.github.io/dea_course/numpy/matplotlib/satellite/2020/08/09/basic-satellite-image-analysis.html",
            "relUrl": "/numpy/matplotlib/satellite/2020/08/09/basic-satellite-image-analysis.html",
            "date": " • Aug 9, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Categorical and missing data",
            "content": "Before we start with this tutorial, let&#39;s have a quick look at a data structure in Python called dictionary. This will help us understand some of the materials in the tutorial and also will help to introduce XArray later on. . A dictionary represents a mapping between keys and values. The keys and values are Python objects of any type. We declare a dictionary using curly braces. Inside we can specify the keys and values using : as a separator and and commas to separate elements in the dictionary. For example: . d = {1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;tree&#39;} . Then we can address or lookup elements in a dictionary using the [ key_name ] to address the value stored under a key. For example: . print(d[1], &quot; + &quot;, d[2], &quot; = &quot;, d[3]) . Elements in a dictionary can be modified or new elements added by doing: . d[3] = &#39;three&#39; d[4] = &#39;four&#39; print(d[1], &quot; + &quot;, d[2], &quot; = &quot;, d[3]) . We start now this tutorial by importing some libraries: . %matplotlib inline import numpy as np import imageio from matplotlib import pyplot as plt from matplotlib import colors from check_answer import check_answer . Categorical data: sometimes remote sensing is used to create classification products. These products do not contain continuous values. They use discrete values to represent the different classes individual pixels can belong to. . As an example, the following cell simulates a very simple image containing three different land cover types. Value 1 represents area covered with grass, 2 croplands and 3 city. . # grass = 1 area = np.ones((100,100)) # crops = 2 area[10:60,20:50] = 2 # city = 3 area[70:90,60:80] = 3 area.shape, area.dtype, np.unique(area) . To visualise the previous array as an image, we are going to define our own colour map using a dictionary in which we can map values to colours: . # We map the values to colours index = {1: &#39;green&#39;, 2: &#39;yellow&#39;, 3: &#39;grey&#39;} # Create a discrete colour map cmap = colors.ListedColormap(index.values()) # Plot plt.imshow(area, cmap=cmap) . Exercise 4.1: The harvesting season has arrived and our cropping lands have changed colour to brown. Can you: . Modify the yellow area to contain the new value 4? | Add a new entry to the index dictionary mapping number 4 to the value brown | area? = ? index? = ? # Regenerate discrete colour map cmap = colors.ListedColormap(index.values()) # Plot plt.imshow(area, cmap=cmap) check_answer(&quot;4.1.1&quot;, area[20,30]), check_answer(&quot;4.1.2&quot;, index[4]) . Masking out regions is a very common practice in remote sensing analysis. For example, the following image reprensents a fake remote sensing image containing a few typical features. . . We start by loading the previous image into a numpy array: . im = imageio.imread(&#39;data/land_mask.png&#39;) plt.imshow(im) . In remote sensing analysis it&#39;s common to be interested in analysing certain features from the Earth surface such as vegetation. Clouds, cloud shadows and even water bodies need to be normally removed or &#39;masked&#39; in order to process the data. . For this example, we have three files containing numpy arrays .npy which represent the masks to filter clouds, shadows and water from our image. . import matplotlib.gridspec as gridspec plt.figure(figsize=(12,8)) gs = gridspec.GridSpec(1,3) # set up a 1 x 3 grid of images ax1=plt.subplot(gs[0,0]) water_mask = np.load(&quot;data/water_mask.npy&quot;) plt.imshow(water_mask) ax1.set_title(&#39;Water Mask&#39;) ax2=plt.subplot(gs[0,1]) cloud_mask = np.load(&quot;data/cloud_mask.npy&quot;) plt.imshow(cloud_mask) ax2.set_title(&#39;Cloud Mask&#39;) ax3=plt.subplot(gs[0,2]) shadow_mask = np.load(&quot;data/shadow_mask.npy&quot;) plt.imshow(shadow_mask) ax3.set_title(&#39;Shadow Mask&#39;) plt.show() . These masks are stored as dtype=uint8 using 1 to indicate presence and 0 for absence of each feature. . Exercise 4.2: Can you use the water mask to set all the pixels in the image array representing water to 0? . Tip: Remember that boolean arrays can be used to index and select regions of another array. To complete this exercise you will need to convert the previous water mask array into boolean types before you can use it. . # 1.- Load the image answ = imageio.imread(&#39;data/land_mask.png&#39;) # 2.- Create a boolean version of the water_mask array bool_water_mask = ? # 3.- Use the previous boolean array to set all pixels in the answ array to 0 answ? # You should see the region with water white plt.imshow(answ) check_answer(&quot;4.2&quot;, answ[200,200]) . Exercise 4.3: Can you do the same as in the previous exercise but now setting to zero the areas covered by clouds, shadows and water? . # 1.- Create a copy of the image answ = np.copy(im) # 2.- Create boolean versions of the masks bool_water_mask = ? bool_cloud_mask = ? bool_shadow_mask = ? # 3.- Use the previous boolean arrays to set all pixels in the answ array to 0 (You might need more than one line) answ? # You should see just green and all the other regions white plt.imshow(answ) check_answer(&quot;4.3&quot;, answ[200,200]+answ[100,100]+answ[100,180]+answ[0,0]) . The previous example demonstrates how categorical data can be used to describe and filter remote sensing images. . In practice, we could have used one array to store our three classes. For example, we could have used the value 1 to designate areas with water, 2 for clouds and 3 for cloud shadows: . mask = water_mask*1 + cloud_mask*2 + shadow_mask*3 plt.imshow(mask) . But this way of representing categories is not very convenient for the case when we can have pixels that can belong to two or more categories at the same time. For example, if we have a pixel that is classified as a cloud shadow and water at the same time, we would need to come up with a new category to represent this case. . Instead, it&#39;s a common practice to use bit flags to create these masking or pixel quality products. Bit flags use the binary representation of a number (using 0s and 1s) to encode the different categories. For example a uint8 number can store values in the range [0-255] and is internally represented with 8 bits which can be either 0 or 1. . In our previous case we could have used the following encoding: . Bit 0: Water 00000001 -&gt; 1 | Bit 1: Cloud 00000010 -&gt; 2 | Bit 2: Shadow 00000100-&gt; 4 | . So, if one pixel is both classified as shadow and water, this pixel would be encoded by the value 5: . 00000101 -&gt; 5 | . Exercise 4.4: How would you represent a pixel that is a cloud and a shadow at the same time? . answ = ? # Print binary format of answ print(f&quot;{answ:08b}&quot;) check_answer(&quot;4.4&quot;, answ) . Some remote sensing collections contain ancillary data describing the quality of each pixel. Below, you can see the table representing how to interpret the bit flags for the Landsat 8 pixel quality product. This product gives information about the quality of each pixel in the reflectance product. . . And this is a real example of a pixel quality Landsat 8 image over Margaret River encoded using the previous bit flags. . pq = imageio.imread(&#39;data/LC08_L1TP_112084_20190820_20190902_01_T1_BQA.tiff&#39;) plt.imshow(pq) pq.shape, pq.dtype, np.unique(pq) . For the value 2720 we can see the binary representation doing: . &quot;{:016b}&quot;.format(2720) . Starting from the right, we find: . bit 5 = 1 -&gt; Cloud | bits 6,7 = 10 -&gt; Medium confidence | bits 8,9 = 10 -&gt; Cirrus medium confidence | bit 11 = 1 -&gt; We don&#39;t know, not included in the table | . Exercise 4.5: Can you work out what is the Cirrus confidence interpretation for the 2976 value in the PQ mask? . print(&quot;{:016b}&quot;.format(2976)) answ = ?# Choose one of &quot;None&quot;, &quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot; check_answer(&quot;4.4&quot;, answ) . Analysing data with NaNs. NaN is a special value of float32 and float64 arrays used to designate Not-a-Number values. For example: . arr = np.array([1,2,3,4,5,np.nan,7,8,9], dtype=np.float32) arr . To compute statistics on arrays containing NaN values, Numpy has special versions of common functions such as mean, std or sum that ignore the NaN values: . print(np.mean(arr)) print(np.nanmean(arr)) . We have been previously filtering out water and cloud effects from images by setting the pixels to 0. However, if we are interested in performing statistics to summarise the information in the image, this could be problematic. For example, consider the following uint16 array in which the value 0 designates no data. If we want to compute the mean of all the valid values, we can do converting the array to float type and then assigning the value 0 to NaN. . arr = np.array([234,243,0,231,219,0,228,220,237], dtype=np.uint16) print(&quot;0s mean:&quot;, np.mean(arr)) arr = arr.astype(np.float32) arr[arr==0]=np.nan print(&quot;NaNs mean:&quot;, np.nanmean(arr)) . Exercise 4.6: Can you calculate the mean value of the green channel for just the area covered with grass in the following image? . . # 1.- Load the image im = imageio.imread(&#39;data/land_mask.png&#39;) # 2.- Select green channel im? # 3.- Change the type of im to float32 im? # 4.- Use the previous boolean array to set all pixels other than grass to NaN im? # You should see the all NaN regions white plt.imshow(im) # 5.- Calculate the mean value answ = ? check_answer(&quot;4.6&quot;, answ) .",
            "url": "https://anu-wald.github.io/dea_course/numpy/2020/08/08/advanced_numpy.html",
            "relUrl": "/numpy/2020/08/08/advanced_numpy.html",
            "date": " • Aug 8, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Introduction to XArray",
            "content": "DEA uses XArray as its data model. To better understand what it is, let&#39;s first do a simple experiment on how we could pack remote sensing data using a combination of plain numpy arrays and Python dictionaries. . Suposse we have a satellite image with three bands: Red, NIR and SWIR. These bands are represented as 2-dimensional numpy arrays. We could also store the latitude and longitude coordinates for each dimension using 1-dimensional arrays. Finally, we could also store some metadata to help describe our images. . %matplotlib inline import numpy as np import matplotlib.pyplot as plt from check_answer import check_answer red = np.random.rand(250,250) nir = np.random.rand(250,250) swir = np.random.rand(250,250) lats = np.linspace(-23.5, -26.0, num=red.shape[0], endpoint=False) lons = np.linspace(110.0, 112.5, num=red.shape[1], endpoint=False) title = &quot;Image of the desert&quot; date = &quot;2019-11-10&quot; image = {&quot;red&quot;: red, &quot;nir&quot;: nir, &quot;swir&quot;: swir, &quot;latitude&quot;: lats, &quot;longitude&quot;: lons, &quot;title&quot;: title, &quot;date&quot;: date} . All our data is conveniently packed in a dictionary. Now we can use this dictionary to work with it: . image[&quot;date&quot;], image[&quot;latitude&quot;][:4] . We can address any variable inside this image dictionary and work directly with other functions. For example, to plot the nir band and calculate its mean: . plt.imshow(image[&#39;nir&#39;]) image[&quot;nir&quot;].mean() . Still, the variables inside our dictionary are independent and we don&#39;t know how they are linked. For example, we have the variable latitude but we don&#39;t know to what axis in the image arrays it refers. We also need to use positional indices to select parts data in the numpy arrays containing the image data. Wouldn&#39;t it be convenient to be able to select data from the images using the coordinates of the pixels instead of their relative positions? . This is exactly what XArray solves! Let&#39;s see how it works: . import xarray as xr from datetime import datetime . To explore XArray we have a file containing some reflectance data of Canberra that has been generated using the DEA library. . The object that we get ds is a XArray Dataset, which in some ways is very similar to the dictionary that we created before, but with lots of convenient functionality available. . ds = xr.open_dataset(&#39;data/canberra_ls8.nc&#39;) ds . This figure, from the documentation page is quite ilustrative on how data is stored in XArray objects: . . A Dataset can be seen as a dictionary structure packing up the data, dimensions and attributes all linked together. . Variables in a Dataset object are called DataArrays and they share dimensions with the higher level Dataset . So far, we have been using 3-dimensional numpy arrays in which the third dimension represented the bands of images and remote sensing data. Numpy can store data in up to 32 dimensions so we could for example use 4-dimensional arrays to store multispectral images with a temporal dimensions, to perform time series analysis. . To facilitate working with these data, DEA follows the convention of storing spectral bands as separate variables storing each one as 3-dimensional cubes containing the temporal dimension. . To access a variable we can access as if it were a Python dictionary, or using the . notation, which is more convenient. . ds[&quot;green&quot;] #or alternatively ds.green . Dimensions are also stored as numerical arrays with the same size as the image&#39;s axis they are referring. . ds[&#39;time&#39;] #or alternatively ds.time . Metadata is referred as Attributes and is internally stored under .attrs, but the same convenient . notation applies to them. . ds.attrs[&#39;Conventions&#39;] #or alternatively ds.Conventions . Exercise 5.1: Can you access to the geospatial_bounds_crs value in the attributes of this XArray Dataset? . answ = ? check_answer(&quot;5.1&quot;, answ) . DataArrays store their data internally as multidimensional numpy arrays. But these arrays contain dimensions or labels that make it easier handle the data. To access the underlaying numpy array of a DataArray we can use the .values notation. . arr = ds.green.values type(arr), arr.shape . Exercise 5.2: Can you store in the answ variable the underlying numpy array containing the longitude dimension in this Dataset? . answ = ? check_answer(&quot;5.2&quot;, answ[0]) . Selecting data and subsetting numpy arrays is done using positional indices to specify positions or ranges of values along the different axis of an array. When we use the [:,:] notation, we need to know beforehand what is the relative position of each axis in our arrays. . XArray provides an abstraction in which we can refer to each axis by its name. Also we can select subsets of the data arrays using two modes or methods: . isel(): For selecting data based on its index (like numpy). | sel(): For selecting data based on its dimension of label value. | . For example, for selecting the first element in the temporal dimension of the green variable we do: . print(&quot;Initial time dimension values:&quot;, ds.green.time.values) ss = ds.green.isel(time=0) ss . On the other hand we can use the .sel() method to select parts of the array by their label or content. See that in this case we do not refer to the data by its positional index but by its dimensional value. . ss = ds.green.sel(time=datetime(2016,1,1)) ss . Both methods sel() and isel() can receive as many arguments as dimensions have the data array. We can use any order in to pass the dimensions and we can also define slices or ranges of values using the slice() notation. For example: . ss = ds.green.sel(time=datetime(2016,1,1), latitude=slice(-35.30,-35.24)) ss . Exercise 5.3: Can you select the region of the red variable delimited by these coordinates: . latitude [-35.30,-35.29] | longitude [149.11,149.13] | . answ = ? check_answer(&quot;5.3&quot;, answ.values.shape) . When we use the selection methods on Datasets and DataArrays we get an object of the same type. . ss = ds.green.sel(time=datetime(2016,1,1), latitude=slice(-35.30,-35.24)) type(ss), type(ds.green) . Exercise 5.4: Use the imshow function to create an image of the first time of the red channel in the dataset. . Tip: Use the .values method to convert the DataArray object into a numpy array, so matplotlib can work with it . answ = ? plt.imshow(answ) check_answer(&quot;5.4&quot;, answ[0,0]) . Xarray exposes lots of functions to perform analisis on Datasets and DataArrays with a similar syntax to numpy&#39;s. For example to calculate the spatial mean of the green band . print(&quot;Mean of green band:&quot;, ds.green.mean()) print(&quot;Standard deviation of green band:&quot;, ds.green.std()) print(&quot;Sum of green band:&quot;, ds.green.sum()) . Exercise 5.5: Can you find the difference between the means of the red and nir channels? . answ = ? check_answer(&quot;5.5&quot;, answ.values) . Plotting is also conveniently integrated as a method on DataArrays. . Note: For plotting you need to pass a 2-dimensional DataArray object, so normally a temporal element needs to be selected. . ds[&quot;green&quot;].isel(time=0).plot() . We still can do things manually using numpy and matplotlib . rgb = np.dstack((ds.red.isel(time=0).values, ds.green.isel(time=0).values, ds.blue.isel(time=0).values)) rgb = np.clip(rgb, 0, 2000) / 2000 plt.imshow(rgb) . The previous image is upside down, so we&#39;d still need to flip the image vertically in numpy to represent it correctly. This has to do with how numerical arrays are stored in netCDF files. . But compare to this elegant way of chaining operations within XArray . # Selection of the bands | time sel | numpy conv| plot (params for plotting function) ds[[&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]].isel(time=0).to_array().plot.imshow(robust=True, figsize=(6, 6)) . Exercise 5.6: Similarly to the previous image, use the .sel() functionality select the subset defined by the following dimension values: . time -&gt; 2017-01-01 | latitude -&gt; [-35.29, -35.27] | longitude -&gt; [149.1, 149.13] | . answ = ? answ.to_array().plot.imshow(robust=True, figsize=(6, 6)) check_answer(&quot;5.6&quot;, answ.to_array().values.shape) . Exercise 5.7: Can you create an NDVI representation of this image? . answ = ? answ.isel(time=0).plot(figsize=(6, 6), cmap=&#39;summer_r&#39;) check_answer(&quot;5.6&quot;, answ.values.shape) .",
            "url": "https://anu-wald.github.io/dea_course/numpy/2020/08/07/intro_to_xarray.html",
            "relUrl": "/numpy/2020/08/07/intro_to_xarray.html",
            "date": " • Aug 7, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Introduction to Remote Sensing",
            "content": "We often associate the term &quot;Remote Sensing&quot; to satellites but this field has a long history that started in the XIX century mounting cameras on hot air balloons. The field really took off as a discipline during the mid XX century with the development of the space technology. The first image from a satellite dates back from the 1960 when the US satellite weather TIROS I was able to capture and send to ground receivers images of the Earth&#39;s atmosphere. . Since then, remote sensing has greatly developed with an increasing number of satellites and types of sensors. Nowadays there are hundreds of satellites which send us a constant stream of information about our planet. . Satellites can be classified by the orbits they describe around the Earth. The most common satellite orbits for environmental remote sensing satellites are geostationary and sun-synchronous polar orbits. Geostationary satellites orbit around us following the Earth&#39;s rotation, so they provide images for a fixed area, normally a half sphere. Polar orbiting satellites circulate our planet at lower altitudes scanning a small fraction of the Earth between the poles in each pass. The following figure shows the consecutive passes and area covered by a polar satellite. The orbit of this satellites is normally synchronised with the sun so they follow a trajectory that coincides with the solar noon -- this is referred as sun-synchronous orbit. . Due to their increased spatial resolution compared to geostationary satellites, polar-orbiting satellites are often preferred for environmental applications and research. DEA provides a high quality collection of high resolution polar orbiting satellite data coming from two missions: Landsat and Sentinel. . The human eye can only capture a limited proportion of the electromagnetic spectrum, which is referred as the visible spectrum. However, the sun emits radiation with a much broader spectrum than the visible light. Sensors in satellites are able to capture the proportion of the Sun&#39;s energy that gets reflected by the Earth at different frequencies. The Earth also emits radiation at lower frequencies than the Sun at what is called the thermal infrarred region. The following figure represents from top to bottom a) the energy spectrum emitted by the Sun and Earth&#39;s determined by the Plank&#39;s law. b) The absortion spectrum of the Earth&#39;s atmosphere which absorbs energy differently depending on the region of the spectrum. c) Representation of the electromagnetic spectrum and names for each region. . The sensors mounted in satellites can measure the energy from a limited number of regions in the spectrum. Multispectral sensors can measure reflected and radiated energy at several regions of the spectrum. The following figure represents the sensing &#39;windows&#39; at which Sentinel 2 and Landsat 7/8 sensors can capture which are tipycally designed to coincide with the atmospheric absortion windows. . The reason why we use multispectral images to study the Earth&#39;s surface is because different materials and processes reflect energy with a unique footprint that help us identify them. For example, two surfaces with very similar colour in the visible spectrum might reflect energy very differently at other regions of the spectrum, which help us to differentiate them using remote sensing images. . To understand this we are going to see the spectral response of different surfaces: . %matplotlib inline import numpy as np import pandas as pd from matplotlib import pyplot as plt .",
            "url": "https://anu-wald.github.io/dea_course/numpy/matplotlib/satellite/2020/08/02/introduction-to-remote-sensing.html",
            "relUrl": "/numpy/matplotlib/satellite/2020/08/02/introduction-to-remote-sensing.html",
            "date": " • Aug 2, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://anu-wald.github.io/dea_course/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://anu-wald.github.io/dea_course/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}